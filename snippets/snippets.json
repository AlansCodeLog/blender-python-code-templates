{
    "addon_info": {
        "prefix": "info addon",
        "body": [
            "bl_info = {",
            "    \"name\": \"${1:My Addon Name}\",",
            "    \"description\": \"${2:Description of this addon}\",",
            "    \"author\": \"${3:Authors name}\",",
            "    \"version\": (${4:0, 0, 1}),",
            "    \"blender\": (${5:2, 9, 0}),",
            "    \"location\": \"${6:View3D}\",",
            "    \"warning\": \"This addon is still in development.\",",
            "    \"wiki_url\": \"\",",
            "    \"category\": \"${7:Object}\" }",
            "    "
        ],
        "description": "Blender addon info"
    },
    "GNU_lisence": {
        "prefix": "lisence gnu",
        "body": [
            "'''",
            "Copyright (C) ${1:2018} ${2:ADDONCREATORNAME}",
            "${3:ADDONCREATORNAME@MAIL.COM}",
            "",
            "Created by ${2:ADDONCREATORNAME}",
            "",
            "    This program is free software: you can redistribute it and/or modify",
            "    it under the terms of the GNU General Public License as published by",
            "    the Free Software Foundation, either version 3 of the License, or",
            "    (at your option) any later version.",
            "",
            "    This program is distributed in the hope that it will be useful,",
            "    but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "    GNU General Public License for more details.",
            "",
            "    You should have received a copy of the GNU General Public License",
            "    along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "'''"
        ],
        "description": "GNU lisence"
    },
    "keymap_item": {
        "prefix": "keymap item",
        "body": [
            "kmi = km.keymap_items.new(",
            "    name=\"${1:keymapname}\",",
            "    idname=\"${2:Operator.bl_idname}\",",
            "    type=\"${3:KEYMAP}\",",
            "    value=\"${4:PRESS}\",",
            "    shift=${5:False},",
            "    ctrl=${6:False},",
            "    alt = ${7:False},",
            "    oskey=${8:False}",
            "    $0)"
        ],
        "description": "keymap item. more info:https://docs.blender.org/api/current/bpy.types.KeyMapItem.html#bpy.types.KeyMapItem"
    },    
    "keymap": {
        "prefix": "keymaps",
        "body": [
            "addon_keymaps = []",
            "def register_keymaps():",
            "    addon = bpy.context.window_manager.keyconfigs.addon",
            "    km = addon.keymaps.new(name = \"3D View\", space_type = \"VIEW_3D\")",
            "    # insert keymap items here",
            "    addon_keymaps.append(km)",
            "",
            "def unregister_keymaps():",
            "    wm = bpy.context.window_manager",
            "    for km in addon_keymaps:",
            "        for kmi in km.keymap_items:",
            "            km.keymap_items.remove(kmi)",
            "        wm.keyconfigs.addon.keymaps.remove(km)",
            "    addon_keymaps.clear()"
        ],
        "description": "Keymaps"
    },
    "menu": {
        "prefix": "menu",
        "body": [
            "class ${1:MenuClassName}(bpy.types.Menu):",
            "    bl_idname = \"${2:view3d.menuname}\"",
            "    bl_label = \"${3:Menu name}\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "        $0"
        ],
        "description": "menu"
    },

    "operator_simple":{
        "prefix": "operator",
        "body": [
            "class ${1:MyClassName}(bpy.types.Operator):",
            "    bl_idname = \"${2:my_operator.my_class_name}\"",
            "    bl_label = \"${3:My Class Name}\"",
            "    bl_description = \"${4:Description that shows in blender tooltips}\"",
            "    bl_options = {\"REGISTER\"}",
            "",
            "    @classmethod",
            "    def poll(cls, context):",
            "        return True",
            "",
            "    def execute(self, context):",
            "        $0",
            "        return {\"FINISHED\"}",
            ""
        ],
        "description": "operator function class, without any imports or added functions"
    },
    "modal_operator":{
        "prefix": "operator modal",
        "body": [
            "class ${1:MyClassName}(bpy.types.Operator):",
            "    bl_idname = \"${2:my_operator.my_class_name}\"",
            "    bl_label = \"${3:My Class Name}\"",
            "    bl_description = \"${4:Description that shows in blender tooltips}\"",
            "    bl_options = {'REGISTER'}",
            "",
            "    @classmethod",
            "    def poll(cls, context):",
            "        return True",
            "",
            "    def invoke(self, context, event):",
            "        context.window_manager.modal_handler_add(self)",
            "        return {\"RUNNING_MODAL\"}",
            "",
            "    def modal(self, context, event):",
            "        ",
            "        if event.type == \"LEFTMOUSE\":",
            "            return {\"FINISHED\"}",
            "        ",
            "        if event.type in {\"RIGHTMOUSE\", \"ESC\"}:",
            "            return {\"CANCELLED\"}",
            "        $0",
            "        return {\"RUNNING_MODAL\"}",
            ""
        ],
        "description": "modal operator function, without any imports or added functions"
    },
    "modal_operator_draw":{
            "prefix": "operator modal",
            "body": [
                "class ${1:MyClassName}(bpy.types.Operator):",
                "    bl_idname = \"${2:my_operator.my_class_name}\"",
                "    bl_label = \"${3:My Class Name}\"",
                "    bl_description = \"${4:Description that shows in blender tooltips}\"",
                "    bl_options = {'REGISTER'}",
                "",
                "    @classmethod",
                "    def poll(cls, context):",
                "        return True",
                "",
                "    def invoke(self, context, event):",
                "        self._handle = bpy.types.SpaceView3D.draw_handler_add(",
                "            self.draw_callback_px, args, \"WINDOW\", \"POST_PIXEL\")",
                "        context.window_manager.modal_handler_add(self)",
                "        return {\"RUNNING_MODAL\"}",
                "",
                "    def modal(self, context, event):",
                "        ",
                "        if event.type == \"LEFTMOUSE\":",
                "            return self.finish()",
                "        ",
                "        if event.type in {\"RIGHTMOUSE\", \"ESC\"}:",
                "            return self.cancelled()",
                "        $0",
                "        return {\"RUNNING_MODAL\"}",
                "",
                "    def finish(self):",
                "        bpy.types.SpaceView3D.draw_handler_remove(self._handle, \"WINDOW\")",
                "        return {\"FINISHED\"}",
                "",
                "    def cancelled(self):",
                "        bpy.types.SpaceView3D.draw_handler_remove(self._handle, \"WINDOW\")",
                "        return {\"CANCELLED\"}",
                "",
                "    def draw_callback_px(tmp, self, context):",
                "        pass",
                ""              
            ],
            "description": "modal operator draw function, without any imports or added functions"
    },
    "panel": {
        "prefix": "panel",
        "body": [
            "class ${1:PanelClassName}(bpy.types.Panel):",
            "    bl_idname = \"${2:panelname}\"",
            "    bl_label = \"${3:Panelname}\"",
            "    bl_space_type = \"${4:VIEW_3D}\"",
            "    bl_region_type = \"${5:TOOLS}\"",
            "    bl_category = \"${6:category}\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "        $0"
        ],
        "description": "Panel"
    },
    "pie_menu": {
        "prefix": "pie menu",
        "body": [
            "class ${1:ClassMenuName}(bpy.types.Menu):",
            "    bl_idname = \"${2:view3d.menuname}\"",
            "    bl_label = \"${3:Menuname}\"",
            "",
            "    def draw(self, context):",
            "        pie = self.layout.menu_pie()",
            "        $0"
        ],
        "description": "Pie menu"
    },
    "register_functions": {
        "prefix": "register",
        "body": [
            "def register():",
            "    bpy.utils.register_module(__name__)",
            "",
            "def unregister():",
            "    bpy.utils.unregister_module(__name__)",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "register and unregister functions"
    },
    "template_addon_add_object":{
        "prefix": "template addon",
        "body": [
            "bl_info = {",
            "    \"name\": \"New Object\",",
            "    \"author\": \"Your Name Here\",",
            "    \"version\": (1, 0),",
            "    \"blender\": (2, 75, 0),",
            "    \"location\": \"View3D > Add > Mesh > New Object\",",
            "    \"description\": \"Adds a new Mesh Object\",",
            "    \"warning\": \"\",",
            "    \"wiki_url\": \"\",",
            "    \"category\": \"Add Mesh\",",
            "    }",
            "",
            "",
            "import bpy",
            "from bpy.types import Operator",
            "from bpy.props import FloatVectorProperty",
            "from bpy_extras.object_utils import AddObjectHelper, object_data_add",
            "from mathutils import Vector",
            "",
            "",
            "def add_object(self, context):",
            "    scale_x = self.scale.x",
            "    scale_y = self.scale.y",
            "",
            "    verts = [Vector((-1 * scale_x, 1 * scale_y, 0)),",
            "             Vector((1 * scale_x, 1 * scale_y, 0)),",
            "             Vector((1 * scale_x, -1 * scale_y, 0)),",
            "             Vector((-1 * scale_x, -1 * scale_y, 0)),",
            "            ]",
            "",
            "    edges = []",
            "    faces = [[0, 1, 2, 3]]",
            "",
            "    mesh = bpy.data.meshes.new(name=\"New Object Mesh\")",
            "    mesh.from_pydata(verts, edges, faces)",
            "    # useful for development when the mesh may be invalid.",
            "    # mesh.validate(verbose=True)",
            "    object_data_add(context, mesh, operator=self)",
            "",
            "",
            "class OBJECT_OT_add_object(Operator, AddObjectHelper):",
            "    \"\"\"Create a new Mesh Object\"\"\"",
            "    bl_idname = \"mesh.add_object\"",
            "    bl_label = \"Add Mesh Object\"",
            "    bl_options = {'REGISTER', 'UNDO'}",
            "",
            "    scale = FloatVectorProperty(",
            "            name=\"scale\",",
            "            default=(1.0, 1.0, 1.0),",
            "            subtype='TRANSLATION',",
            "            description=\"scaling\",",
            "            )",
            "",
            "    def execute(self, context):",
            "",
            "        add_object(self, context)",
            "",
            "        return {'FINISHED'}",
            "",
            "",
            "# Registration",
            "",
            "def add_object_button(self, context):",
            "    self.layout.operator(",
            "        OBJECT_OT_add_object.bl_idname,",
            "        text=\"Add Object\",",
            "        icon='PLUGIN')",
            "",
            "",
            "# This allows you to right click on a button and link to the manual",
            "def add_object_manual_map():",
            "    url_manual_prefix = \"https://docs.blender.org/manual/en/dev/\"",
            "    url_manual_mapping = (",
            "        (\"bpy.ops.mesh.add_object\", \"editors/3dview/object\"),",
            "        )",
            "    return url_manual_prefix, url_manual_mapping",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(OBJECT_OT_add_object)",
            "    bpy.utils.register_manual_map(add_object_manual_map)",
            "    bpy.types.INFO_MT_mesh_add.append(add_object_button)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(OBJECT_OT_add_object)",
            "    bpy.utils.unregister_manual_map(add_object_manual_map)",
            "    bpy.types.INFO_MT_mesh_add.remove(add_object_button)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "Example of addon for adding object"
    },
    "template_background_job":{
        "prefix": "template background job",
        "body": [
            "# This script is an example of how you can run blender from the command line",
            "# (in background mode with no interface) to automate tasks, in this example it",
            "# creates a text object, camera and light, then renders and/or saves it.",
            "# This example also shows how you can parse command line options to scripts.",
            "#",
            "# Example usage for this test.",
            "#  blender --background --factory-startup --python $HOME/background_job.py -- \\",
            "#          --text=\"Hello World\" \\",
            "#          --render=\"/tmp/hello\" \\",
            "#          --save=\"/tmp/hello.blend\"",
            "#",
            "# Notice:",
            "# '--factory-startup' is used to avoid the user default settings from",
            "#                     interfering with automated scene generation.",
            "#",
            "# '--' causes blender to ignore all following arguments so python can use them.",
            "#",
            "# See blender --help for details.",
            "",
            "import bpy",
            "",
            "",
            "def example_function(text, save_path, render_path):",
            "",
            "    scene = bpy.context.scene",
            "",
            "    # Clear existing objects.",
            "    scene.camera = None",
            "    for obj in scene.objects:",
            "        scene.objects.unlink(obj)",
            "",
            "    txt_data = bpy.data.curves.new(name=\"MyText\", type='FONT')",
            "",
            "    # Text Object",
            "    txt_ob = bpy.data.objects.new(name=\"MyText\", object_data=txt_data)",
            "    scene.objects.link(txt_ob)  # add the data to the scene as an object",
            "    txt_data.body = text        # the body text to the command line arg given",
            "    txt_data.align = 'CENTER'   # center text",
            "",
            "    # Camera",
            "    cam_data = bpy.data.cameras.new(\"MyCam\")",
            "    cam_ob = bpy.data.objects.new(name=\"MyCam\", object_data=cam_data)",
            "    scene.objects.link(cam_ob)  # instance the camera object in the scene",
            "    scene.camera = cam_ob       # set the active camera",
            "    cam_ob.location = 0.0, 0.0, 10.0",
            "",
            "    # Lamp",
            "    lamp_data = bpy.data.lamps.new(\"MyLamp\", 'POINT')",
            "    lamp_ob = bpy.data.objects.new(name=\"MyCam\", object_data=lamp_data)",
            "    scene.objects.link(lamp_ob)",
            "    lamp_ob.location = 2.0, 2.0, 5.0",
            "",
            "    if save_path:",
            "        bpy.ops.wm.save_as_mainfile(filepath=save_path)",
            "",
            "    if render_path:",
            "        render = scene.render",
            "        render.use_file_extension = True",
            "        render.filepath = render_path",
            "        bpy.ops.render.render(write_still=True)",
            "",
            "",
            "def main():",
            "    import sys       # to get command line args",
            "    import argparse  # to parse options for us and print a nice help message",
            "",
            "    # get the args passed to blender after \"--\", all of which are ignored by",
            "    # blender so scripts may receive their own arguments",
            "    argv = sys.argv",
            "",
            "    if \"--\" not in argv:",
            "        argv = []  # as if no args are passed",
            "    else:",
            "        argv = argv[argv.index(\"--\") + 1:]  # get all args after \"--\"",
            "",
            "    # When --help or no args are given, print this help",
            "    usage_text = (",
            "            \"Run blender in background mode with this script:\"",
            "            \"  blender --background --python \" + __file__ + \" -- [options]\"",
            "            )",
            "",
            "    parser = argparse.ArgumentParser(description=usage_text)",
            "",
            "    # Example utility, add some text and renders or saves it (with options)",
            "    # Possible types are: string, int, long, choice, float and complex.",
            "    parser.add_argument(\"-t\", \"--text\", dest=\"text\", type=str, required=True,",
            "            help=\"This text will be used to render an image\")",
            "",
            "    parser.add_argument(\"-s\", \"--save\", dest=\"save_path\", metavar='FILE',",
            "            help=\"Save the generated file to the specified path\")",
            "    parser.add_argument(\"-r\", \"--render\", dest=\"render_path\", metavar='FILE',",
            "            help=\"Render an image to the specified path\")",
            "",
            "    args = parser.parse_args(argv)  # In this example we wont use the args",
            "",
            "    if not argv:",
            "        parser.print_help()",
            "        return",
            "",
            "    if not args.text:",
            "        print(\"Error: --text=\\\"some string\\\" argument not given, aborting.\")",
            "        parser.print_help()",
            "        return",
            "",
            "    # Run the example function",
            "    example_function(args.text, args.save_path, args.render_path)",
            "",
            "    print(\"batch job finished, exiting\")",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "description": "Example of script that shows how you can run blender from the command line (in background mode with no interface) to automate tasks, in this example it creates a text object, camera and light, then renders and/or saves it. This example also shows how you can parse command line options to scripts."
    },
    "template_batch_export":{
        "prefix": "template batch",
        "body": [
            "# exports each selected object into its own file",
            "",
            "import bpy",
            "import os",
            "",
            "# export to blend file location",
            "basedir = os.path.dirname(bpy.data.filepath)",
            "",
            "if not basedir:",
            "    raise Exception(\"Blend file is not saved\")",
            "",
            "scene = bpy.context.scene",
            "",
            "obj_active = scene.objects.active",
            "selection = bpy.context.selected_objects",
            "",
            "bpy.ops.object.select_all(action='DESELECT')",
            "",
            "for obj in selection:",
            "",
            "    obj.select = True",
            "",
            "    # some exporters only use the active object",
            "    scene.objects.active = obj",
            "",
            "    name = bpy.path.clean_name(obj.name)",
            "    fn = os.path.join(basedir, name)",
            "",
            "    bpy.ops.export_scene.fbx(filepath=fn + \".fbx\", use_selection=True)",
            "",
            "    ## Can be used for multiple formats",
            "    # bpy.ops.export_scene.x3d(filepath=fn + \".x3d\", use_selection=True)",
            "",
            "    obj.select = False",
            "",
            "    print(\"written:\", fn)",
            "",
            "",
            "scene.objects.active = obj_active",
            "",
            "for obj in selection:",
            "    obj.select = True"
        ],
        "description": "Example of exporting each selected object into its own file"
    },
    "template_bmesh_simple_editmode":{
        "prefix": "template bmesh",
        "body": [
            "# This example assumes we have a mesh object in edit-mode",
            "",
            "import bpy",
            "import bmesh",
            "",
            "# Get the active mesh",
            "obj = bpy.context.edit_object",
            "me = obj.data",
            "",
            "",
            "# Get a BMesh representation",
            "bm = bmesh.from_edit_mesh(me)",
            "",
            "bm.faces.active = None",
            "",
            "# Modify the BMesh, can do anything here...",
            "for v in bm.verts:",
            "    v.co.x += 1.0",
            "",
            "",
            "# Show the updates in the viewport",
            "# and recalculate n-gon tessellation.",
            "bmesh.update_edit_mesh(me, True)"
        ],
        "description": "Example of to get mesh representation for bmesh from edit-mode and updating it back after bmesh operation."
    },
    "template_bmesh_simple_active_object":{
        "prefix": "template bmesh",
        "body": [
            "# This example assumes we have a mesh object selected",
            "",
            "import bpy",
            "import bmesh",
            "",
            "# Get the active mesh",
            "me = bpy.context.object.data",
            "",
            "",
            "# Get a BMesh representation",
            "bm = bmesh.new()   # create an empty BMesh",
            "bm.from_mesh(me)   # fill it in from a Mesh",
            "",
            "",
            "# Modify the BMesh, can do anything here...",
            "for v in bm.verts:",
            "    v.co.x += 1.0",
            "",
            "",
            "# Finish up, write the bmesh back to the mesh",
            "bm.to_mesh(me)",
            "bm.free()  # free and prevent further access"
        ],
        "description": "Example of to get mesh representation for bmesh from active object and updating it back after bmesh operation."
    },
    "template_builtin_keyingset":{
        "prefix": "template keyingset",
        "body": [
            "import bpy",
            "",
            "",
            "class BUILTIN_KSI_hello(bpy.types.KeyingSetInfo):",
            "    bl_label = \"Hello World KeyingSet\"",
            "",
            "    # poll - test for whether Keying Set can be used at all",
            "    def poll(ksi, context):",
            "        return context.active_object or context.selected_objects",
            "",
            "    # iterator - go over all relevant data, calling generate()",
            "    def iterator(ksi, context, ks):",
            "        for ob in context.selected_objects:",
            "            ksi.generate(context, ks, ob)",
            "",
            "    # generator - populate Keying Set with property paths to use",
            "    def generate(ksi, context, ks, data):",
            "        id_block = data.id_data",
            "",
            "        ks.paths.add(id_block, \"location\")",
            "",
            "        for i in range(5):",
            "            ks.paths.add(id_block, \"layers\", i, group_method='NAMED', group_name=\"5x Hello Layers\")",
            "",
            "        ks.paths.add(id_block, \"show_x_ray\", group_method='NONE')",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(BUILTIN_KSI_hello)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(BUILTIN_KSI_hello)",
            "",
            "",
            "if __name__ == '__main__':",
            "    register()"
        ],
        "description": "Example of generating Keying Set"
    },
    "template_custom_nodes":{
        "prefix": "template nodes",
        "body": [
            "import bpy",
            "from bpy.types import NodeTree, Node, NodeSocket",
            "",
            "# Implementation of custom nodes from Python",
            "",
            "",
            "# Derived from the NodeTree base type, similar to Menu, Operator, Panel, etc.",
            "class MyCustomTree(NodeTree):",
            "    # Description string",
            "    '''A custom node tree type that will show up in the node editor header'''",
            "    # Optional identifier string. If not explicitly defined, the python class name is used.",
            "    bl_idname = 'CustomTreeType'",
            "    # Label for nice name display",
            "    bl_label = 'Custom Node Tree'",
            "    # Icon identifier",
            "    bl_icon = 'NODETREE'",
            "",
            "",
            "# Custom socket type",
            "class MyCustomSocket(NodeSocket):",
            "    # Description string",
            "    '''Custom node socket type'''",
            "    # Optional identifier string. If not explicitly defined, the python class name is used.",
            "    bl_idname = 'CustomSocketType'",
            "    # Label for nice name display",
            "    bl_label = 'Custom Node Socket'",
            "",
            "    # Enum items list",
            "    my_items = [",
            "        (\"DOWN\", \"Down\", \"Where your feet are\"),",
            "        (\"UP\", \"Up\", \"Where your head should be\"),",
            "        (\"LEFT\", \"Left\", \"Not right\"),",
            "        (\"RIGHT\", \"Right\", \"Not left\")",
            "    ]",
            "",
            "    myEnumProperty = bpy.props.EnumProperty(name=\"Direction\", description=\"Just an example\", items=my_items, default='UP')",
            "",
            "    # Optional function for drawing the socket input value",
            "    def draw(self, context, layout, node, text):",
            "        if self.is_output or self.is_linked:",
            "            layout.label(text)",
            "        else:",
            "            layout.prop(self, \"myEnumProperty\", text=text)",
            "",
            "    # Socket color",
            "    def draw_color(self, context, node):",
            "        return (1.0, 0.4, 0.216, 0.5)",
            "",
            "",
            "# Mix-in class for all custom nodes in this tree type.",
            "# Defines a poll function to enable instantiation.",
            "class MyCustomTreeNode:",
            "    @classmethod",
            "    def poll(cls, ntree):",
            "        return ntree.bl_idname == 'CustomTreeType'",
            "",
            "",
            "# Derived from the Node base type.",
            "class MyCustomNode(Node, MyCustomTreeNode):",
            "    # === Basics ===",
            "    # Description string",
            "    '''A custom node'''",
            "    # Optional identifier string. If not explicitly defined, the python class name is used.",
            "    bl_idname = 'CustomNodeType'",
            "    # Label for nice name display",
            "    bl_label = 'Custom Node'",
            "    # Icon identifier",
            "    bl_icon = 'SOUND'",
            "",
            "    # === Custom Properties ===",
            "    # These work just like custom properties in ID data blocks",
            "    # Extensive information can be found under",
            "    # http://wiki.blender.org/index.php/Doc:2.6/Manual/Extensions/Python/Properties",
            "    myStringProperty = bpy.props.StringProperty()",
            "    myFloatProperty = bpy.props.FloatProperty(default=3.1415926)",
            "",
            "    # === Optional Functions ===",
            "    # Initialization function, called when a new node is created.",
            "    # This is the most common place to create the sockets for a node, as shown below.",
            "    # NOTE: this is not the same as the standard __init__ function in Python, which is",
            "    #       a purely internal Python method and unknown to the node system!",
            "    def init(self, context):",
            "        self.inputs.new('CustomSocketType', \"Hello\")",
            "        self.inputs.new('NodeSocketFloat', \"World\")",
            "        self.inputs.new('NodeSocketVector', \"!\")",
            "",
            "        self.outputs.new('NodeSocketColor', \"How\")",
            "        self.outputs.new('NodeSocketColor', \"are\")",
            "        self.outputs.new('NodeSocketFloat', \"you\")",
            "",
            "    # Copy function to initialize a copied node from an existing one.",
            "    def copy(self, node):",
            "        print(\"Copying from node \", node)",
            "",
            "    # Free function to clean up on removal.",
            "    def free(self):",
            "        print(\"Removing node \", self, \", Goodbye!\")",
            "",
            "    # Additional buttons displayed on the node.",
            "    def draw_buttons(self, context, layout):",
            "        layout.label(\"Node settings\")",
            "        layout.prop(self, \"myFloatProperty\")",
            "",
            "    # Detail buttons in the sidebar.",
            "    # If this function is not defined, the draw_buttons function is used instead",
            "    def draw_buttons_ext(self, context, layout):",
            "        layout.prop(self, \"myFloatProperty\")",
            "        # myStringProperty button will only be visible in the sidebar",
            "        layout.prop(self, \"myStringProperty\")",
            "",
            "    # Optional: custom label",
            "    # Explicit user label overrides this, but here we can define a label dynamically",
            "    def draw_label(self):",
            "        return \"I am a custom node\"",
            "",
            "",
            "### Node Categories ###",
            "# Node categories are a python system for automatically",
            "# extending the Add menu, toolbar panels and search operator.",
            "# For more examples see release/scripts/startup/nodeitems_builtins.py",
            "",
            "import nodeitems_utils",
            "from nodeitems_utils import NodeCategory, NodeItem",
            "",
            "",
            "# our own base class with an appropriate poll function,",
            "# so the categories only show up in our own tree type",
            "class MyNodeCategory(NodeCategory):",
            "    @classmethod",
            "    def poll(cls, context):",
            "        return context.space_data.tree_type == 'CustomTreeType'",
            "",
            "# all categories in a list",
            "node_categories = [",
            "    # identifier, label, items list",
            "    MyNodeCategory(\"SOMENODES\", \"Some Nodes\", items=[",
            "        # our basic node",
            "        NodeItem(\"CustomNodeType\"),",
            "        ]),",
            "    MyNodeCategory(\"OTHERNODES\", \"Other Nodes\", items=[",
            "        # the node item can have additional settings,",
            "        # which are applied to new nodes",
            "        # NB: settings values are stored as string expressions,",
            "        # for this reason they should be converted to strings using repr()",
            "        NodeItem(\"CustomNodeType\", label=\"Node A\", settings={",
            "            \"myStringProperty\": repr(\"Lorem ipsum dolor sit amet\"),",
            "            \"myFloatProperty\": repr(1.0),",
            "            }),",
            "        NodeItem(\"CustomNodeType\", label=\"Node B\", settings={",
            "            \"myStringProperty\": repr(\"consectetur adipisicing elit\"),",
            "            \"myFloatProperty\": repr(2.0),",
            "            }),",
            "        ]),",
            "    ]",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(MyCustomTree)",
            "    bpy.utils.register_class(MyCustomSocket)",
            "    bpy.utils.register_class(MyCustomNode)",
            "",
            "    nodeitems_utils.register_node_categories(\"CUSTOM_NODES\", node_categories)",
            "",
            "",
            "def unregister():",
            "    nodeitems_utils.unregister_node_categories(\"CUSTOM_NODES\")",
            "",
            "    bpy.utils.unregister_class(MyCustomTree)",
            "    bpy.utils.unregister_class(MyCustomSocket)",
            "    bpy.utils.unregister_class(MyCustomNode)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "Example of Implementation of custom nodes from Python"
    },
    "template_driver_functions":{
        "prefix": "template driver",
        "body": [
            "# This script defines functions to be used directly in drivers expressions to",
            "# extend the builtin set of python functions.",
            "#",
            "# This can be executed on manually or set to 'Register' to",
            "# initialize thefunctions on file load.",
            "",
            "",
            "# two sample functions",
            "def invert(f):",
            "    \"\"\" Simple function call:",
            "",
            "            invert(val)",
            "    \"\"\"",
            "    return 1.0 - f",
            "",
            "",
            "uuid_store = {}",
            "",
            "",
            "def slow_value(value, fac, uuid):",
            "    \"\"\" Delay the value by a factor, use a unique string to allow",
            "        use in multiple drivers without conflict:",
            "",
            "            slow_value(val, 0.5, \"my_value\")",
            "    \"\"\"",
            "    value_prev = uuid_store.get(uuid, value)",
            "    uuid_store[uuid] = value_new = (value_prev * fac) + (value * (1.0 - fac))",
            "    return value_new",
            "",
            "",
            "import bpy",
            "",
            "# Add variable defined in this script into the drivers namespace.",
            "bpy.app.driver_namespace[\"invert\"] = invert",
            "bpy.app.driver_namespace[\"slow_value\"] = slow_value"
        ],
        "description": "Example of script defining functions to be used directly in drivers expressions to extend the builtin set of python functions."
    },
    "template_external_script_stub":{
        "prefix": "template script",
        "body": [
            "# This stub runs a python script relative to the currently open",
            "# blend file, useful when editing scripts externally.",
            "",
            "import bpy",
            "import os",
            "",
            "# Use your own script name here:",
            "filename = \"my_script.py\"",
            "",
            "filepath = os.path.join(os.path.dirname(bpy.data.filepath), filename)",
            "global_namespace = {\"__file__\": filepath, \"__name__\": \"__main__\"}",
            "with open(filepath, 'rb') as file:",
            "    exec(compile(file.read(), filepath, 'exec'), global_namespace)"
        ],
        "description": "Example of loading script relative to current blend file. This stub runs a python script relative to the currently open blend file, useful when editing scripts externally."
    },
    "template_gamelogic_module":{
        "prefix": "template gamelogic",
        "body": [
            "# This module can be accessed by a python controller with",
            "# its execution method set to 'Module'",
            "# * Set the module string to \"gamelogic_module.main\" (without quotes)",
            "# * When renaming the script it MUST have a .py extension",
            "# * External text modules are supported as long as they are at",
            "#   the same location as the blendfile or one of its libraries.",
            "",
            "import bge",
            "",
            "# variables defined here will only be set once when the",
            "# module is first imported. Set object specific vars",
            "# inside the function if you intend to use the module",
            "# with multiple objects.",
            "",
            "",
            "def main(cont):",
            "    own = cont.owner",
            "",
            "    sens = cont.sensors['mySensor']",
            "    actu = cont.actuators['myActuator']",
            "",
            "    if sens.positive:",
            "        cont.activate(actu)",
            "    else:",
            "        cont.deactivate(actu)",
            "",
            "# dont call main(bge.logic.getCurrentController()), the py controller will"
        ],
        "description": "Example of gamelogic module. This module can be accessed by a python controller with its execution method set to 'Module'"
    },
    "template_gamelogic_simple":{
        "prefix": "template gamelogic",
        "body": [
            "import bge",
            "",
            "",
            "def main():",
            "",
            "    cont = bge.logic.getCurrentController()",
            "    own = cont.owner",
            "",
            "    sens = cont.sensors['mySensor']",
            "    actu = cont.actuators['myActuator']",
            "",
            "    if sens.positive:",
            "        cont.activate(actu)",
            "    else:",
            "        cont.deactivate(actu)",
            "",
            "main()"
        ],
        "description": "Example of Simple gamelogic python script."
    },
    "template_gamelogic":{
        "prefix": "template gamelogic",
        "body": [
            "# This script must be assigned to a python controller",
            "# where it can access the object that owns it and the sensors/actuators that it connects to.",
            "",
            "import bge",
            "",
            "# support for Vector(), Matrix() types and advanced functions like Matrix.Scale(...) and Matrix.Rotation(...)",
            "# import mathutils",
            "",
            "# for functions like getWindowWidth(), getWindowHeight()",
            "# import Rasterizer",
            "",
            "",
            "def main():",
            "    cont = bge.logic.getCurrentController()",
            "",
            "    # The KX_GameObject that owns this controller.",
            "    own = cont.owner",
            "",
            "    # for scripts that deal with spacial logic",
            "    own_pos = own.worldPosition",
            "",
            "    # Some example functions, remove to write your own script.",
            "    # check for a positive sensor, will run on any object without errors.",
            "    print(\"Logic info for KX_GameObject\", own.name)",
            "    input = False",
            "",
            "    for sens in cont.sensors:",
            "        # The sensor can be on another object, we may want to use it",
            "        own_sens = sens.owner",
            "        print(\"    sensor:\", sens.name, end=\" \")",
            "        if sens.positive:",
            "            print(\"(true)\")",
            "            input = True",
            "        else:",
            "            print(\"(false)\")",
            "",
            "    for actu in cont.actuators:",
            "        # The actuator can be on another object, we may want to use it",
            "        own_actu = actu.owner",
            "        print(\"    actuator:\", actu.name)",
            "",
            "        # This runs the actuator or turns it off",
            "        # note that actuators will continue to run unless explicitly turned off.",
            "        if input:",
            "            cont.activate(actu)",
            "        else:",
            "            cont.deactivate(actu)",
            "",
            "    # Its also good practice to get sensors and actuators by name",
            "    # rather then index so any changes to their order wont break the script.",
            "",
            "    # sens_key = cont.sensors[\"key_sensor\"]",
            "    # actu_motion = cont.actuators[\"motion\"]",
            "",
            "    # Loop through all other objects in the scene",
            "    sce = bge.logic.getCurrentScene()",
            "    print(\"Scene Objects:\", sce.name)",
            "    for ob in sce.objects:",
            "        print(\"   \", ob.name, ob.worldPosition)",
            "",
            "    # Example where collision objects are checked for their properties",
            "    # adding to our objects \"life\" property",
            "    \"\"\"",
            "    actu_collide = cont.sensors[\"collision_sens\"]",
            "    for ob in actu_collide.hitObjectList:",
            "        # Check to see the object has this property",
            "        if \"life\" in ob:",
            "            own[\"life\"] += ob[\"life\"]",
            "            ob[\"life\"] = 0",
            "    print(own[\"life\"])",
            "    \"\"\"",
            "",
            "main()"
        ],
        "description": "Example of gamelogic script this must be assigned to a python controller where it can access the object that owns it and the sensors/actuators that it connects to."
    },
    "template_operator_file_export":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "",
            "",
            "def write_some_data(context, filepath, use_some_setting):",
            "    print(\"running write_some_data...\")",
            "    f = open(filepath, 'w', encoding='utf-8')",
            "    f.write(\"Hello World %s\" % use_some_setting)",
            "    f.close()",
            "",
            "    return {'FINISHED'}",
            "",
            "",
            "# ExportHelper is a helper class, defines filename and",
            "# invoke() function which calls the file selector.",
            "from bpy_extras.io_utils import ExportHelper",
            "from bpy.props import StringProperty, BoolProperty, EnumProperty",
            "from bpy.types import Operator",
            "",
            "",
            "class ExportSomeData(Operator, ExportHelper):",
            "    \"\"\"This appears in the tooltip of the operator and in the generated docs\"\"\"",
            "    bl_idname = \"export_test.some_data\"  # important since its how bpy.ops.import_test.some_data is constructed",
            "    bl_label = \"Export Some Data\"",
            "",
            "    # ExportHelper mixin class uses this",
            "    filename_ext = \".txt\"",
            "",
            "    filter_glob = StringProperty(",
            "            default=\"*.txt\",",
            "            options={'HIDDEN'},",
            "            maxlen=255,  # Max internal buffer length, longer would be clamped.",
            "            )",
            "",
            "    # List of operator properties, the attributes will be assigned",
            "    # to the class instance from the operator settings before calling.",
            "    use_setting = BoolProperty(",
            "            name=\"Example Boolean\",",
            "            description=\"Example Tooltip\",",
            "            default=True,",
            "            )",
            "",
            "    type = EnumProperty(",
            "            name=\"Example Enum\",",
            "            description=\"Choose between two items\",",
            "            items=(('OPT_A', \"First Option\", \"Description one\"),",
            "                   ('OPT_B', \"Second Option\", \"Description two\")),",
            "            default='OPT_A',",
            "            )",
            "",
            "    def execute(self, context):",
            "        return write_some_data(context, self.filepath, self.use_setting)",
            "",
            "",
            "# Only needed if you want to add into a dynamic menu",
            "def menu_func_export(self, context):",
            "    self.layout.operator(ExportSomeData.bl_idname, text=\"Text Export Operator\")",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(ExportSomeData)",
            "    bpy.types.INFO_MT_file_export.append(menu_func_export)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(ExportSomeData)",
            "    bpy.types.INFO_MT_file_export.remove(menu_func_export)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()",
            "",
            "    # test call",
            "    bpy.ops.export_test.some_data('INVOKE_DEFAULT')"
        ],
        "description": "Example of Template for file export operator, operator exports data from blender to .txt file"
    },
    "template_operator_file_import":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "",
            "",
            "def read_some_data(context, filepath, use_some_setting):",
            "    print(\"running read_some_data...\")",
            "    f = open(filepath, 'r', encoding='utf-8')",
            "    data = f.read()",
            "    f.close()",
            "",
            "    # would normally load the data here",
            "    print(data)",
            "",
            "    return {'FINISHED'}",
            "",
            "",
            "# ImportHelper is a helper class, defines filename and",
            "# invoke() function which calls the file selector.",
            "from bpy_extras.io_utils import ImportHelper",
            "from bpy.props import StringProperty, BoolProperty, EnumProperty",
            "from bpy.types import Operator",
            "",
            "",
            "class ImportSomeData(Operator, ImportHelper):",
            "    \"\"\"This appears in the tooltip of the operator and in the generated docs\"\"\"",
            "    bl_idname = \"import_test.some_data\"  # important since its how bpy.ops.import_test.some_data is constructed",
            "    bl_label = \"Import Some Data\"",
            "",
            "    # ImportHelper mixin class uses this",
            "    filename_ext = \".txt\"",
            "",
            "    filter_glob = StringProperty(",
            "            default=\"*.txt\",",
            "            options={'HIDDEN'},",
            "            maxlen=255,  # Max internal buffer length, longer would be clamped.",
            "            )",
            "",
            "    # List of operator properties, the attributes will be assigned",
            "    # to the class instance from the operator settings before calling.",
            "    use_setting = BoolProperty(",
            "            name=\"Example Boolean\",",
            "            description=\"Example Tooltip\",",
            "            default=True,",
            "            )",
            "",
            "    type = EnumProperty(",
            "            name=\"Example Enum\",",
            "            description=\"Choose between two items\",",
            "            items=(('OPT_A', \"First Option\", \"Description one\"),",
            "                   ('OPT_B', \"Second Option\", \"Description two\")),",
            "            default='OPT_A',",
            "            )",
            "",
            "    def execute(self, context):",
            "        return read_some_data(context, self.filepath, self.use_setting)",
            "",
            "",
            "# Only needed if you want to add into a dynamic menu",
            "def menu_func_import(self, context):",
            "    self.layout.operator(ImportSomeData.bl_idname, text=\"Text Import Operator\")",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(ImportSomeData)",
            "    bpy.types.INFO_MT_file_import.append(menu_func_import)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(ImportSomeData)",
            "    bpy.types.INFO_MT_file_import.remove(menu_func_import)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()",
            "",
            "    # test call",
            "    bpy.ops.import_test.some_data('INVOKE_DEFAULT')"
        ],
        "description": "Example of Template for file import operator, operator imports data from .txt to blender data"
    },
    "template_opertator_mesh_add":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "import bmesh",
            "",
            "",
            "def add_box(width, height, depth):",
            "    \"\"\"",
            "    This function takes inputs and returns vertex and face arrays.",
            "    no actual mesh data creation is done here.",
            "    \"\"\"",
            "",
            "    verts = [(+1.0, +1.0, -1.0),",
            "             (+1.0, -1.0, -1.0),",
            "             (-1.0, -1.0, -1.0),",
            "             (-1.0, +1.0, -1.0),",
            "             (+1.0, +1.0, +1.0),",
            "             (+1.0, -1.0, +1.0),",
            "             (-1.0, -1.0, +1.0),",
            "             (-1.0, +1.0, +1.0),",
            "             ]",
            "",
            "    faces = [(0, 1, 2, 3),",
            "             (4, 7, 6, 5),",
            "             (0, 4, 5, 1),",
            "             (1, 5, 6, 2),",
            "             (2, 6, 7, 3),",
            "             (4, 0, 3, 7),",
            "            ]",
            "",
            "    # apply size",
            "    for i, v in enumerate(verts):",
            "        verts[i] = v[0] * width, v[1] * depth, v[2] * height",
            "",
            "    return verts, faces",
            "",
            "",
            "from bpy.props import (",
            "        BoolProperty,",
            "        BoolVectorProperty,",
            "        FloatProperty,",
            "        FloatVectorProperty,",
            "        )",
            "",
            "",
            "class AddBox(bpy.types.Operator):",
            "    \"\"\"Add a simple box mesh\"\"\"",
            "    bl_idname = \"mesh.primitive_box_add\"",
            "    bl_label = \"Add Box\"",
            "    bl_options = {'REGISTER', 'UNDO'}",
            "",
            "    width = FloatProperty(",
            "            name=\"Width\",",
            "            description=\"Box Width\",",
            "            min=0.01, max=100.0,",
            "            default=1.0,",
            "            )",
            "    height = FloatProperty(",
            "            name=\"Height\",",
            "            description=\"Box Height\",",
            "            min=0.01, max=100.0,",
            "            default=1.0,",
            "            )",
            "    depth = FloatProperty(",
            "            name=\"Depth\",",
            "            description=\"Box Depth\",",
            "            min=0.01, max=100.0,",
            "            default=1.0,",
            "            )",
            "    layers = BoolVectorProperty(",
            "            name=\"Layers\",",
            "            description=\"Object Layers\",",
            "            size=20,",
            "            options={'HIDDEN', 'SKIP_SAVE'},",
            "            )",
            "",
            "    # generic transform props",
            "    view_align = BoolProperty(",
            "            name=\"Align to View\",",
            "            default=False,",
            "            )",
            "    location = FloatVectorProperty(",
            "            name=\"Location\",",
            "            subtype='TRANSLATION',",
            "            )",
            "    rotation = FloatVectorProperty(",
            "            name=\"Rotation\",",
            "            subtype='EULER',",
            "            )",
            "",
            "    def execute(self, context):",
            "",
            "        verts_loc, faces = add_box(self.width,",
            "                                   self.height,",
            "                                   self.depth,",
            "                                   )",
            "",
            "        mesh = bpy.data.meshes.new(\"Box\")",
            "",
            "        bm = bmesh.new()",
            "",
            "        for v_co in verts_loc:",
            "            bm.verts.new(v_co)",
            "",
            "        bm.verts.ensure_lookup_table()",
            "        for f_idx in faces:",
            "            bm.faces.new([bm.verts[i] for i in f_idx])",
            "",
            "        bm.to_mesh(mesh)",
            "        mesh.update()",
            "",
            "        # add the mesh as an object into the scene with this utility module",
            "        from bpy_extras import object_utils",
            "        object_utils.object_data_add(context, mesh, operator=self)",
            "",
            "        return {'FINISHED'}",
            "",
            "",
            "def menu_func(self, context):",
            "    self.layout.operator(AddBox.bl_idname, icon='MESH_CUBE')",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(AddBox)",
            "    bpy.types.INFO_MT_mesh_add.append(menu_func)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(AddBox)",
            "    bpy.types.INFO_MT_mesh_add.remove(menu_func)",
            "",
            "if __name__ == \"__main__\":",
            "    register()",
            "",
            "    # test call",
            "    bpy.ops.mesh.primitive_box_add()"
        ],
        "description": "Example of operator involving bmesh for creating and adding object to scene"
    },
    "template_operator_mesh_uv":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "import bmesh",
            "",
            "",
            "def main(context):",
            "    obj = context.active_object",
            "    me = obj.data",
            "    bm = bmesh.from_edit_mesh(me)",
            "",
            "    uv_layer = bm.loops.layers.uv.verify()",
            "    bm.faces.layers.tex.verify()  # currently blender needs both layers.",
            "",
            "    # adjust UVs",
            "    for f in bm.faces:",
            "        for l in f.loops:",
            "            luv = l[uv_layer]",
            "            if luv.select:",
            "                # apply the location of the vertex as a UV",
            "                luv.uv = l.vert.co.xy",
            "",
            "    bmesh.update_edit_mesh(me)",
            "",
            "",
            "class UvOperator(bpy.types.Operator):",
            "    \"\"\"UV Operator description\"\"\"",
            "    bl_idname = \"uv.simple_operator\"",
            "    bl_label = \"Simple UV Operator\"",
            "",
            "    @classmethod",
            "    def poll(cls, context):",
            "        return (context.mode == 'EDIT_MESH')",
            "",
            "    def execute(self, context):",
            "        main(context)",
            "        return {'FINISHED'}",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(UvOperator)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(UvOperator)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()",
            "",
            "    # test call",
            "    bpy.ops.uv.simple_operator()"
        ],
        "description": "Example of Operator template for editing mesh UV's with bmesh"
    },
    "template_operator_simple":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "",
            "",
            "def main(context):",
            "    for ob in context.scene.objects:",
            "        print(ob)",
            "",
            "",
            "class SimpleOperator(bpy.types.Operator):",
            "    \"\"\"Tooltip\"\"\"",
            "    bl_idname = \"object.simple_operator\"",
            "    bl_label = \"Simple Object Operator\"",
            "",
            "    @classmethod",
            "    def poll(cls, context):",
            "        return context.active_object is not None",
            "",
            "    def execute(self, context):",
            "        main(context)",
            "        return {'FINISHED'}",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(SimpleOperator)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(SimpleOperator)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()",
            "",
            "    # test call",
            "    bpy.ops.object.simple_operator()"
        ],
        "description": "Example of Blender modal operator function with imports, main function, register, unregister and testcall"
    },
    "template_ui_list_w_panel":{
        "prefix": "template ui list",
        "body": [
            "import bpy",
            "",
            "",
            "class MATERIAL_UL_matslots_example(bpy.types.UIList):",
            "    # The draw_item function is called for each item of the collection that is visible in the list.",
            "    #   data is the RNA object containing the collection,",
            "    #   item is the current drawn item of the collection,",
            "    #   icon is the \"computed\" icon for the item (as an integer, because some objects like materials or textures",
            "    #   have custom icons ID, which are not available as enum items).",
            "    #   active_data is the RNA object containing the active property for the collection (i.e. integer pointing to the",
            "    #   active item of the collection).",
            "    #   active_propname is the name of the active property (use 'getattr(active_data, active_propname)').",
            "    #   index is index of the current item in the collection.",
            "    #   flt_flag is the result of the filtering process for this item.",
            "    #   Note: as index and flt_flag are optional arguments, you do not have to use/declare them here if you don't",
            "    #         need them.",
            "    def draw_item(self, context, layout, data, item, icon, active_data, active_propname):",
            "        ob = data",
            "        slot = item",
            "        ma = slot.material",
            "        # draw_item must handle the three layout types... Usually 'DEFAULT' and 'COMPACT' can share the same code.",
            "        if self.layout_type in {'DEFAULT', 'COMPACT'}:",
            "            # You should always start your row layout by a label (icon + text), or a non-embossed text field,",
            "            # this will also make the row easily selectable in the list! The later also enables ctrl-click rename.",
            "            # We use icon_value of label, as our given icon is an integer value, not an enum ID.",
            "            # Note \"data\" names should never be translated!",
            "            if ma:",
            "                layout.prop(ma, \"name\", text=\"\", emboss=False, icon_value=icon)",
            "            else:",
            "                layout.label(text=\"\", translate=False, icon_value=icon)",
            "            # And now we can add other UI stuff...",
            "            # Here, we add nodes info if this material uses (old!) shading nodes.",
            "            if ma and not context.scene.render.use_shading_nodes:",
            "                manode = ma.active_node_material",
            "                if manode:",
            "                    # The static method UILayout.icon returns the integer value of the icon ID \"computed\" for the given",
            "                    # RNA object.",
            "                    layout.label(text=\"Node %s\" % manode.name, translate=False, icon_value=layout.icon(manode))",
            "                elif ma.use_nodes:",
            "                    layout.label(text=\"Node <none>\", translate=False)",
            "                else:",
            "                    layout.label(text=\"\")",
            "        # 'GRID' layout type should be as compact as possible (typically a single icon!).",
            "        elif self.layout_type in {'GRID'}:",
            "            layout.alignment = 'CENTER'",
            "            layout.label(text=\"\", icon_value=icon)",
            "",
            "",
            "# And now we can use this list everywhere in Blender. Here is a small example panel.",
            "class UIListPanelExample(bpy.types.Panel):",
            "    \"\"\"Creates a Panel in the Object properties window\"\"\"",
            "    bl_label = \"UIList Panel\"",
            "    bl_idname = \"OBJECT_PT_ui_list_example\"",
            "    bl_space_type = 'PROPERTIES'",
            "    bl_region_type = 'WINDOW'",
            "    bl_context = \"object\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "",
            "        obj = context.object",
            "",
            "        # template_list now takes two new args.",
            "        # The first one is the identifier of the registered UIList to use (if you want only the default list,",
            "        # with no custom draw code, use \"UI_UL_list\").",
            "        layout.template_list(\"MATERIAL_UL_matslots_example\", \"\", obj, \"material_slots\", obj, \"active_material_index\")",
            "",
            "        # The second one can usually be left as an empty string. It's an additional ID used to distinguish lists in case you",
            "        # use the same list several times in a given area.",
            "        layout.template_list(\"MATERIAL_UL_matslots_example\", \"compact\", obj, \"material_slots\",",
            "                             obj, \"active_material_index\", type='COMPACT')",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(MATERIAL_UL_matslots_example)",
            "    bpy.utils.register_class(UIListPanelExample)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(MATERIAL_UL_matslots_example)",
            "    bpy.utils.unregister_class(UIListPanelExample)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "Example of ui list template with adding it to blender with example panel"
    },
    "template_ui_list":{
        "prefix": "template ui list",
        "body": [
            "import bpy",
            "",
            "",
            "class MESH_UL_mylist(bpy.types.UIList):",
            "    # Constants (flags)",
            "    # Be careful not to shadow FILTER_ITEM (i.e. UIList().bitflag_filter_item)!",
            "    # E.g. VGROUP_EMPTY = 1 << 0",
            "",
            "    # Custom properties, saved with .blend file. E.g.",
            "    # use_filter_empty = bpy.props.BoolProperty(name=\"Filter Empty\", default=False, options=set(),",
            "    #                                           description=\"Whether to filter empty vertex groups\")",
            "",
            "    # Called for each drawn item.",
            "    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index, flt_flag):",
            "        # 'DEFAULT' and 'COMPACT' layout types should usually use the same draw code.",
            "        if self.layout_type in {'DEFAULT', 'COMPACT'}:",
            "            pass",
            "        # 'GRID' layout type should be as compact as possible (typically a single icon!).",
            "        elif self.layout_type in {'GRID'}:",
            "            pass",
            "",
            "    # Called once to draw filtering/reordering options.",
            "    def draw_filter(self, context, layout):",
            "        # Nothing much to say here, it's usual UI code...",
            "        pass",
            "",
            "    # Called once to filter/reorder items.",
            "    def filter_items(self, context, data, propname):",
            "        # This function gets the collection property (as the usual tuple (data, propname)), and must return two lists:",
            "        # * The first one is for filtering, it must contain 32bit integers were self.bitflag_filter_item marks the",
            "        #   matching item as filtered (i.e. to be shown), and 31 other bits are free for custom needs. Here we use the",
            "        #   first one to mark VGROUP_EMPTY.",
            "        # * The second one is for reordering, it must return a list containing the new indices of the items (which",
            "        #   gives us a mapping org_idx -> new_idx).",
            "        # Please note that the default UI_UL_list defines helper functions for common tasks (see its doc for more info).",
            "        # If you do not make filtering and/or ordering, return empty list(s) (this will be more efficient than",
            "        # returning full lists doing nothing!).",
            "",
            "        # Default return values.",
            "        flt_flags = []",
            "        flt_neworder = []",
            "",
            "        # Do filtering/reordering here...",
            "",
            "        return flt_flags, flt_neworder"
        ],
        "description": "Example of simple ui list class with some filtering and bpy import"
    },
    "template_ui_menu_simple":{
        "prefix": "template ui menu",
        "body": [
            "import bpy",
            "",
            "",
            "class SimpleCustomMenu(bpy.types.Menu):",
            "    bl_label = \"Simple Custom Menu\"",
            "    bl_idname = \"OBJECT_MT_simple_custom_menu\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "",
            "        layout.operator(\"wm.open_mainfile\")",
            "        layout.operator(\"wm.save_as_mainfile\")",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(SimpleCustomMenu)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(SimpleCustomMenu)",
            "",
            "if __name__ == \"__main__\":",
            "    register()",
            "",
            "    # The menu can also be called from scripts",
            "    bpy.ops.wm.call_menu(name=SimpleCustomMenu.bl_idname)"
        ],
        "description": "Example of ui menu"
    },
    "template_ui_panel_simple":{
        "prefix": "template ui simple panel",
        "body": [
            "import bpy",
            "",
            "",
            "class HelloWorldPanel(bpy.types.Panel):",
            "    \"\"\"Creates a Panel in the Object properties window\"\"\"",
            "    bl_label = \"Hello World Panel\"",
            "    bl_idname = \"OBJECT_PT_hello\"",
            "    bl_space_type = 'PROPERTIES'",
            "    bl_region_type = 'WINDOW'",
            "    bl_context = \"object\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "",
            "        obj = context.object",
            "",
            "        row = layout.row()",
            "        row.label(text=\"Hello world!\", icon='WORLD_DATA')",
            "",
            "        row = layout.row()",
            "        row.label(text=\"Active object is: \" + obj.name)",
            "        row = layout.row()",
            "        row.prop(obj, \"name\")",
            "",
            "        row = layout.row()",
            "        row.operator(\"mesh.primitive_cube_add\")",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(HelloWorldPanel)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(HelloWorldPanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "Example of ui panel class with import and register"
    },
    "template_ui_panel":{
        "prefix": "template ui panel",
        "body": [
            "import bpy",
            "",
            "",
            "class LayoutDemoPanel(bpy.types.Panel):",
            "    \"\"\"Creates a Panel in the scene context of the properties editor\"\"\"",
            "    bl_label = \"Layout Demo\"",
            "    bl_idname = \"SCENE_PT_layout\"",
            "    bl_space_type = 'PROPERTIES'",
            "    bl_region_type = 'WINDOW'",
            "    bl_context = \"scene\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "",
            "        scene = context.scene",
            "",
            "        # Create a simple row.",
            "        layout.label(text=\" Simple Row:\")",
            "",
            "        row = layout.row()",
            "        row.prop(scene, \"frame_start\")",
            "        row.prop(scene, \"frame_end\")",
            "",
            "        # Create an row where the buttons are aligned to each other.",
            "        layout.label(text=\" Aligned Row:\")",
            "",
            "        row = layout.row(align=True)",
            "        row.prop(scene, \"frame_start\")",
            "        row.prop(scene, \"frame_end\")",
            "",
            "        # Create two columns, by using a split layout.",
            "        split = layout.split()",
            "",
            "        # First column",
            "        col = split.column()",
            "        col.label(text=\"Column One:\")",
            "        col.prop(scene, \"frame_end\")",
            "        col.prop(scene, \"frame_start\")",
            "",
            "        # Second column, aligned",
            "        col = split.column(align=True)",
            "        col.label(text=\"Column Two:\")",
            "        col.prop(scene, \"frame_start\")",
            "        col.prop(scene, \"frame_end\")",
            "",
            "        # Big render button",
            "        layout.label(text=\"Big Button:\")",
            "        row = layout.row()",
            "        row.scale_y = 3.0",
            "        row.operator(\"render.render\")",
            "",
            "        # Different sizes in a row",
            "        layout.label(text=\"Different button sizes:\")",
            "        row = layout.row(align=True)",
            "        row.operator(\"render.render\")",
            "",
            "        sub = row.row()",
            "        sub.scale_x = 2.0",
            "        sub.operator(\"render.render\")",
            "",
            "        row.operator(\"render.render\")",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(LayoutDemoPanel)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(LayoutDemoPanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "Example of ui panel class ui panel is created with examples of columns, buttons, rows, properties, with import and register, "
    },
    "template_ui_pie_menu":{
        "prefix": "template ui pie menu",
        "body": [
            "import bpy",
            "from bpy.types import Menu",
            "",
            "# spawn an edit mode selection pie (run while object is in edit mode to get a valid output)",
            "",
            "",
            "class VIEW3D_PIE_template(Menu):",
            "    # label is displayed at the center of the pie menu.",
            "    bl_label = \"Select Mode\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "",
            "        pie = layout.menu_pie()",
            "        # operator_enum will just spread all available options",
            "        # for the type enum of the operator on the pie",
            "        pie.operator_enum(\"mesh.select_mode\", \"type\")",
            "",
            "",
            "def register():",
            "    bpy.utils.register_class(VIEW3D_PIE_template)",
            "",
            "",
            "def unregister():",
            "    bpy.utils.unregister_class(VIEW3D_PIE_template)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()",
            "",
            "    bpy.ops.wm.call_menu_pie(name=\"VIEW3D_PIE_template\")"
        ],
        "description": "Example of 3d viewport pie menu"
    },
    "template_dynamic_enum":{
        "prefix": "template dynamic enum",
        "body": [
            "# This sample script demonstrates a dynamic EnumProperty with custom icons.",
            "# The EnumProperty is populated dynamically with thumbnails of the contents of",
            "# a chosen directory in 'enum_previews_from_directory_items'.",
            "# Then, the same enum is displayed with different interfaces. Note that the",
            "# generated icon previews do not have Blender IDs, which means that they can",
            "# not be used with UILayout templates that require IDs,",
            "# such as template_list and template_ID_preview.",
            "#",
            "# Other use cases:",
            "# - make a fixed list of enum_items instead of calculating them in a function",
            "# - generate isolated thumbnails to use as custom icons in buttons",
            "#   and menu items",
            "#",
            "# For custom icons, see the template \"ui_previews_custom_icon.py\".",
            "#",
            "# For distributable scripts, it is recommended to place the icons inside the",
            "# script directory and access it relative to the py script file for portability:",
            "#",
            "#    os.path.join(os.path.dirname(__file__), \"images\")",
            "",
            "",
            "import os",
            "import bpy",
            "",
            "",
            "def enum_previews_from_directory_items(self, context):",
            "    \"\"\"EnumProperty callback\"\"\"",
            "    enum_items = []",
            "",
            "    if context is None:",
            "        return enum_items",
            "",
            "    wm = context.window_manager",
            "    directory = wm.my_previews_dir",
            "",
            "    # Get the preview collection (defined in register func).",
            "    pcoll = preview_collections[\"main\"]",
            "",
            "    if directory == pcoll.my_previews_dir:",
            "        return pcoll.my_previews",
            "",
            "    print(\"Scanning directory: %s\" % directory)",
            "",
            "    if directory and os.path.exists(directory):",
            "        # Scan the directory for png files",
            "        image_paths = []",
            "        for fn in os.listdir(directory):",
            "            if fn.lower().endswith(\".png\"):",
            "                image_paths.append(fn)",
            "",
            "        for i, name in enumerate(image_paths):",
            "            # generates a thumbnail preview for a file.",
            "            filepath = os.path.join(directory, name)",
            "            thumb = pcoll.load(filepath, filepath, 'IMAGE')",
            "            enum_items.append((name, name, \"\", thumb.icon_id, i))",
            "",
            "    pcoll.my_previews = enum_items",
            "    pcoll.my_previews_dir = directory",
            "    return pcoll.my_previews",
            "",
            "",
            "class PreviewsExamplePanel(bpy.types.Panel):",
            "    \"\"\"Creates a Panel in the Object properties window\"\"\"",
            "    bl_label = \"Previews Example Panel\"",
            "    bl_idname = \"OBJECT_PT_previews\"",
            "    bl_space_type = 'PROPERTIES'",
            "    bl_region_type = 'WINDOW'",
            "    bl_context = \"object\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "        wm = context.window_manager",
            "",
            "        row = layout.row()",
            "        row.prop(wm, \"my_previews_dir\")",
            "",
            "        row = layout.row()",
            "        row.template_icon_view(wm, \"my_previews\")",
            "",
            "        row = layout.row()",
            "        row.prop(wm, \"my_previews\")",
            "",
            "",
            "# We can store multiple preview collections here,",
            "# however in this example we only store \"main\"",
            "preview_collections = {}",
            "",
            "",
            "def register():",
            "    from bpy.types import WindowManager",
            "    from bpy.props import (",
            "            StringProperty,",
            "            EnumProperty,",
            "            )",
            "",
            "    WindowManager.my_previews_dir = StringProperty(",
            "            name=\"Folder Path\",",
            "            subtype='DIR_PATH',",
            "            default=\"\"",
            "            )",
            "",
            "    WindowManager.my_previews = EnumProperty(",
            "            items=enum_previews_from_directory_items,",
            "            )",
            "",
            "    # Note that preview collections returned by bpy.utils.previews",
            "    # are regular Python objects - you can use them to store custom data.",
            "    #",
            "    # This is especially useful here, since:",
            "    # - It avoids us regenerating the whole enum over and over.",
            "    # - It can store enum_items' strings",
            "    #   (remember you have to keep those strings somewhere in py,",
            "    #   else they get freed and Blender references invalid memory!).",
            "    import bpy.utils.previews",
            "    pcoll = bpy.utils.previews.new()",
            "    pcoll.my_previews_dir = \"\"",
            "    pcoll.my_previews = ()",
            "",
            "    preview_collections[\"main\"] = pcoll",
            "",
            "    bpy.utils.register_class(PreviewsExamplePanel)",
            "",
            "",
            "def unregister():",
            "    from bpy.types import WindowManager",
            "",
            "    del WindowManager.my_previews",
            "",
            "    for pcoll in preview_collections.values():",
            "        bpy.utils.previews.remove(pcoll)",
            "    preview_collections.clear()",
            "",
            "    bpy.utils.unregister_class(PreviewsExamplePanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "This Example script demonstrates a dynamic EnumProperty with custom icons."
    },
    "template_ui_previews_custom_icon":{
        "prefix": "template ui previews",
        "body": [
            "# This sample script demonstrates how to place a custom icon on a button or",
            "# menu entry.",
            "#",
            "# IMPORTANT NOTE: if you run this sample, there will be no icon in the button",
            "# You need to replace the image path with a real existing one.",
            "# For distributable scripts, it is recommended to place the icons inside the",
            "# addon folder and access it relative to the py script file for portability",
            "#",
            "#",
            "# Other use cases for UI-previews:",
            "# - provide a fixed list of previews to select from",
            "# - provide a dynamic list of preview (eg. calculated from reading a directory)",
            "#",
            "# For the above use cases, see the template 'ui_previews_dynamic_enum.py\"",
            "",
            "",
            "import os",
            "import bpy",
            "",
            "",
            "class PreviewsExamplePanel(bpy.types.Panel):",
            "    \"\"\"Creates a Panel in the Object properties window\"\"\"",
            "    bl_label = \"Previews Example Panel\"",
            "    bl_idname = \"OBJECT_PT_previews\"",
            "    bl_space_type = 'PROPERTIES'",
            "    bl_region_type = 'WINDOW'",
            "    bl_context = \"object\"",
            "",
            "    def draw(self, context):",
            "        layout = self.layout",
            "        pcoll = preview_collections[\"main\"]",
            "",
            "        row = layout.row()",
            "        my_icon = pcoll[\"my_icon\"]",
            "        row.operator(\"render.render\", icon_value=my_icon.icon_id)",
            "",
            "        # my_icon.icon_id can be used in any UI function that accepts",
            "        # icon_value # try also setting text=\"\"",
            "        # to get an icon only operator button",
            "",
            "",
            "# We can store multiple preview collections here,",
            "# however in this example we only store \"main\"",
            "preview_collections = {}",
            "",
            "",
            "def register():",
            "",
            "    # Note that preview collections returned by bpy.utils.previews",
            "    # are regular py objects - you can use them to store custom data.",
            "    import bpy.utils.previews",
            "    pcoll = bpy.utils.previews.new()",
            "",
            "    # path to the folder where the icon is",
            "    # the path is calculated relative to this py file inside the addon folder",
            "    my_icons_dir = os.path.join(os.path.dirname(__file__), \"icons\")",
            "",
            "    # load a preview thumbnail of a file and store in the previews collection",
            "    pcoll.load(\"my_icon\", os.path.join(my_icons_dir, \"icon-image.png\"), 'IMAGE')",
            "",
            "    preview_collections[\"main\"] = pcoll",
            "",
            "    bpy.utils.register_class(PreviewsExamplePanel)",
            "",
            "",
            "def unregister():",
            "",
            "    for pcoll in preview_collections.values():",
            "        bpy.utils.previews.remove(pcoll)",
            "    preview_collections.clear()",
            "",
            "    bpy.utils.unregister_class(PreviewsExamplePanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    register()"
        ],
        "description": "This example script demonstrates how to place a custom icon on a button menu entry."
    }

}